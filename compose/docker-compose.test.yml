services:
  # Simulate the ECS container startup for testing
  openemr-test:
    image: openemr/openemr:7.0.4
    container_name: openemr-container-test
    # Exact copy of startup script from compute.py - matches production ECS deployment
    command:
      - /bin/sh
      - -c
      - |
        set -e
        set -x
        log() { echo "[$$(date +%Y-%m-%d\ %H:%M:%S)] $$*"; }
        log "=== OpenEMR Container Startup Script ==="
        log "Starting container initialization..."
        cd /var/www/localhost/htdocs/openemr || { log "ERROR: Failed to change to OpenEMR directory"; exit 1; }
        if [ "$$PWD" != "/var/www/localhost/htdocs/openemr" ]; then
          log "ERROR: Working directory verification failed. Expected /var/www/localhost/htdocs/openemr, got $$PWD"
          exit 1
        fi
        log "Working directory verified: $$PWD"
        if ! id apache >/dev/null 2>&1; then
          log "ERROR: Apache user does not exist in container image"
          exit 1
        fi
        log "Apache user verified"
        log "Checking EFS sites directory initialization..."
        if [ ! -d /var/www/localhost/htdocs/openemr/sites/default ] || [ ! -f /var/www/localhost/htdocs/openemr/sites/default/sqlconf.php ]; then
          log "EFS sites directory missing or uninitialized, restoring from image..."
          if [ ! -d /swarm-pieces/sites ]; then
            log "ERROR: Source directory /swarm-pieces/sites not found in container image"
            exit 1
          fi
          rsync --owner --group --perms --recursive --links --verbose /swarm-pieces/sites /var/www/localhost/htdocs/openemr/ || {
            log "ERROR: Failed to restore site skeleton from image"
            exit 1
          }
          log "Site skeleton restored successfully"
        else
          log "EFS sites directory already initialized"
        fi
        log "Creating certificate directories..."
        mkdir -p /var/www/localhost/htdocs/openemr/sites/default/documents/certificates /root/certs/redis /root/certs/mysql/server || {
          log "ERROR: Failed to create certificate directories"
          exit 1
        }
        for dir in /var/www/localhost/htdocs/openemr/sites/default/documents/certificates /root/certs/redis /root/certs/mysql/server; do
          if [ ! -d "$$dir" ]; then
            log "ERROR: Directory $$dir was not created"
            exit 1
          fi
        done
        log "Certificate directories created and verified"
        log "Downloading Amazon Root CA1 for Redis/Valkey TLS..."
        REDIS_CA_URL="https://www.amazontrust.com/repository/AmazonRootCA1.pem"
        REDIS_CA_PATH="/root/certs/redis/redis-ca"
        if [ ! -f "$$REDIS_CA_PATH" ] || [ ! -s "$$REDIS_CA_PATH" ]; then
          curl -f --max-time 30 --connect-timeout 10 --retry 3 --retry-delay 2 --retry-connrefused --cacert /swarm-pieces/ssl/certs/ca-certificates.crt -o "$$REDIS_CA_PATH" "$$REDIS_CA_URL" || {
            log "ERROR: Failed to download Redis CA certificate from $$REDIS_CA_URL"
            exit 1
          }
          if [ ! -f "$$REDIS_CA_PATH" ] || [ ! -s "$$REDIS_CA_PATH" ]; then
            log "ERROR: Redis CA certificate file is missing or empty after download"
            exit 1
          fi
          # Validate certificate is a reasonable size (Amazon Root CA should be ~1-5KB)
          CERT_SIZE=$$(wc -c < "$$REDIS_CA_PATH")
          if [ "$$CERT_SIZE" -lt 500 ] || [ "$$CERT_SIZE" -gt 10000 ]; then
            log "ERROR: Redis CA certificate size ($$CERT_SIZE bytes) is outside expected range (500-10000 bytes)"
            exit 1
          fi
          # Validate certificate is valid PEM format
          if ! head -n 1 "$$REDIS_CA_PATH" | grep -q "BEGIN CERTIFICATE" 2>/dev/null; then
            log "ERROR: Redis CA certificate does not appear to be valid PEM format"
            exit 1
          fi
          log "Redis CA certificate downloaded successfully ($$CERT_SIZE bytes) and validated"
        else
          log "Redis CA certificate already exists, skipping download"
        fi
        chown apache "$$REDIS_CA_PATH" || { log "ERROR: Failed to set ownership on Redis CA certificate"; exit 1; }
        log "Redis CA certificate ready"
        log "Downloading RDS CA bundle for MySQL SSL..."
        MYSQL_CA_URL="https://truststore.pki.rds.amazonaws.com/global/global-bundle.pem"
        MYSQL_CA_PATH="/root/certs/mysql/server/mysql-ca"
        if [ ! -f "$$MYSQL_CA_PATH" ] || [ ! -s "$$MYSQL_CA_PATH" ]; then
          curl -f --max-time 30 --connect-timeout 10 --retry 3 --retry-delay 2 --retry-connrefused --cacert /swarm-pieces/ssl/certs/ca-certificates.crt -o "$$MYSQL_CA_PATH" "$$MYSQL_CA_URL" || {
            log "ERROR: Failed to download MySQL CA certificate from $$MYSQL_CA_URL"
            exit 1
          }
          if [ ! -f "$$MYSQL_CA_PATH" ] || [ ! -s "$$MYSQL_CA_PATH" ]; then
            log "ERROR: MySQL CA certificate file is missing or empty after download"
            exit 1
          fi
          # Validate certificate bundle is a reasonable size (RDS CA bundle should be ~100-500KB)
          CERT_SIZE=$$(wc -c < "$$MYSQL_CA_PATH")
          if [ "$$CERT_SIZE" -lt 10000 ] || [ "$$CERT_SIZE" -gt 1000000 ]; then
            log "ERROR: MySQL CA certificate bundle size ($$CERT_SIZE bytes) is outside expected range (10000-1000000 bytes)"
            exit 1
          fi
          # Validate certificate bundle contains valid PEM format
          if ! head -n 1 "$$MYSQL_CA_PATH" | grep -q "BEGIN CERTIFICATE" 2>/dev/null; then
            log "ERROR: MySQL CA certificate bundle does not appear to be valid PEM format"
            exit 1
          fi
          log "MySQL CA certificate bundle downloaded successfully ($$CERT_SIZE bytes) and validated"
        else
          log "MySQL CA certificate already exists, skipping download"
        fi
        chown apache "$$MYSQL_CA_PATH" || { log "ERROR: Failed to set ownership on MySQL CA certificate"; exit 1; }
        log "Deploying MySQL CA certificate to OpenEMR certificates directory..."
        OPENEMR_CA_PATH="/var/www/localhost/htdocs/openemr/sites/default/documents/certificates/mysql-ca"
        cp "$$MYSQL_CA_PATH" "$$OPENEMR_CA_PATH" || {
          log "ERROR: Failed to copy MySQL CA certificate to OpenEMR directory"
          exit 1
        }
        chown apache "$$OPENEMR_CA_PATH" || { log "ERROR: Failed to set ownership on OpenEMR MySQL CA certificate"; exit 1; }
        chmod 744 "$$OPENEMR_CA_PATH" || { log "ERROR: Failed to set permissions on OpenEMR MySQL CA certificate"; exit 1; }
        if [ ! -f "$$OPENEMR_CA_PATH" ] || [ ! -r "$$OPENEMR_CA_PATH" ]; then
          log "ERROR: OpenEMR MySQL CA certificate is missing or not readable after deployment"
          exit 1
        fi
        log "MySQL CA certificate deployed successfully"
        # --- OpenEMR Bootstrap Reliability (RDS TLS + idempotent retries) ---
        log "Applying OpenEMR bootstrap reliability fixes (RDS TLS + retry safety)..."
        if [ -d "/tmp/php-file-cache" ]; then
          log "Removing stale /tmp/php-file-cache from prior attempt"
          rm -rf "/tmp/php-file-cache" 2>/dev/null || true
        fi
        if [ -f "/root/devtoolsLibrary.source" ]; then
          if grep -q -- "--skip-ssl" /root/devtoolsLibrary.source 2>/dev/null; then
            log "Patching /root/devtoolsLibrary.source: removing --skip-ssl to allow TLS to DB"
            sed -i 's/ --skip-ssl//g' /root/devtoolsLibrary.source 2>/dev/null || true
          fi
        fi
        log "Verifying critical files and directories..."
        for path in "$$REDIS_CA_PATH" "$$MYSQL_CA_PATH" "$$OPENEMR_CA_PATH" /var/www/localhost/htdocs/openemr/sites/default; do
          if [ ! -e "$$path" ]; then
            log "ERROR: Critical path missing: $$path"
            exit 1
          fi
        done
        log "All critical paths verified"
        log "Performing final preparation steps..."
        if [ ! -f ./openemr.sh ]; then
          log "ERROR: openemr.sh not found in working directory"
          exit 1
        fi
        chmod +x ./openemr.sh || { log "ERROR: Failed to make openemr.sh executable"; exit 1; }
        log "openemr.sh is executable"
        if ! grep -q "httpd -k graceful" /etc/crontabs/root 2>/dev/null; then
          echo "1 23  *   *   *   httpd -k graceful" >> /etc/crontabs/root
          log "Added Apache graceful restart cron job"
        else
          log "Apache graceful restart cron job already exists"
        fi
        log "=== Container initialization complete ==="
        log "Verifying EFS mount points are writable..."
        EFS_SITES_TEST_FILE="/var/www/localhost/htdocs/openemr/sites/.efs_write_test"
        EFS_SSL_TEST_FILE="/etc/ssl/.efs_write_test"
        # Test sites EFS writability
        if touch "$$EFS_SITES_TEST_FILE" 2>/dev/null && rm -f "$$EFS_SITES_TEST_FILE" 2>/dev/null; then
          log "EFS sites mount verified (writable)"
        else
          log "ERROR: EFS sites mount is not writable. Cannot proceed with setup."
          exit 1
        fi
        # Test SSL EFS writability
        if touch "$$EFS_SSL_TEST_FILE" 2>/dev/null && rm -f "$$EFS_SSL_TEST_FILE" 2>/dev/null; then
          log "EFS SSL mount verified (writable)"
        else
          log "ERROR: EFS SSL mount is not writable. Cannot proceed with setup."
          exit 1
        fi
        log "All EFS mounts verified and writable"
        log "Checking database connectivity..."
        if [ -z "$$MYSQL_HOST" ] || [ -z "$$MYSQL_ROOT_PASS" ]; then
          log "WARNING: Database credentials not available for readiness check, will rely on OpenEMR retry logic"
        else
          DB_READY=0
          MAX_ATTEMPTS=30
          INITIAL_DELAY=2
          CURRENT_DELAY=$$INITIAL_DELAY
          for attempt in $$(seq 1 $$MAX_ATTEMPTS); do
            # Use mysqladmin ping if available, otherwise fall back to nc (netcat)
            if command -v mysqladmin >/dev/null 2>&1; then
              MYSQLADMIN_CMD="mysqladmin ping -h \"$$MYSQL_HOST\" -u \"$$MYSQL_ROOT_USER\" -p\"$$MYSQL_ROOT_PASS\""
              # Always use TLS for DB connections (matches production)
              if [ -n "$$MYSQL_CA_PATH" ] && [ -f "$$MYSQL_CA_PATH" ]; then
                MYSQLADMIN_CMD="$$MYSQLADMIN_CMD --ssl-ca=\"$$MYSQL_CA_PATH\" --ssl-mode=REQUIRED"
              else
                MYSQLADMIN_CMD="$$MYSQLADMIN_CMD --ssl-mode=REQUIRED"
              fi
              if eval "$$MYSQLADMIN_CMD" --silent 2>/dev/null; then
                log "Database connectivity verified (attempt $$attempt/$$MAX_ATTEMPTS)"
                DB_READY=1
                break
              fi
            elif command -v nc >/dev/null 2>&1 && [ -n "$$MYSQL_PORT" ]; then
              # Fallback: check if port is open (does not verify database is ready, but better than nothing)
              if nc -z -w 3 "$$MYSQL_HOST" "$${MYSQL_PORT:-3306}" 2>/dev/null; then
                log "Database port is reachable (attempt $$attempt/$$MAX_ATTEMPTS), assuming ready"
                DB_READY=1
                break
              fi
            else
              log "WARNING: Neither mysqladmin nor nc available for database readiness check"
              DB_READY=1  # Assume ready if we cannot check
              break
            fi
            if [ "$$attempt" -lt "$$MAX_ATTEMPTS" ]; then
              log "Database not ready yet, waiting $${CURRENT_DELAY}s before retry (attempt $$attempt/$$MAX_ATTEMPTS)..."
              sleep $$CURRENT_DELAY
              # Exponential backoff: double delay each attempt, max 60s
              CURRENT_DELAY=$$((CURRENT_DELAY * 2))
              if [ "$$CURRENT_DELAY" -gt 60 ]; then
                CURRENT_DELAY=60
              fi
            fi
          done
          if [ "$$DB_READY" -eq 0 ]; then
            log "WARNING: Database readiness check failed after $$MAX_ATTEMPTS attempts"
            log "Database may still be initializing. OpenEMR will retry setup automatically."
          fi
        fi
        log "Checking Valkey/Redis connectivity..."
        if [ -z "$$REDIS_SERVER" ] || [ "$$REDIS_SERVER" = "null" ]; then
          log "Valkey/Redis not configured, skipping connectivity check"
        else
          # Extract host and port from REDIS_SERVER (format: host:port or host)
          REDIS_HOST="$${REDIS_SERVER%%:*}"
          REDIS_PORT="$${REDIS_SERVER##*:}"
          # If no colon found, REDIS_PORT will equal REDIS_HOST (entire string), use default port
          if [ "$$REDIS_PORT" = "$$REDIS_HOST" ] || [ -z "$$REDIS_PORT" ]; then
            REDIS_PORT="6379"  # Default Redis port
          fi
          if command -v nc >/dev/null 2>&1; then
            if nc -z -w 3 "$$REDIS_HOST" "$$REDIS_PORT" 2>/dev/null; then
              log "Valkey/Redis connectivity verified ($$REDIS_HOST:$$REDIS_PORT)"
            else
              log "WARNING: Valkey/Redis not reachable at $$REDIS_HOST:$$REDIS_PORT"
              log "Application may have degraded cache functionality, but will continue startup"
            fi
          else
            log "WARNING: nc (netcat) not available for Valkey/Redis connectivity check"
          fi
        fi
        log "Checking for stale docker-leader files..."
        LEADER_FILE="/var/www/localhost/htdocs/openemr/sites/docker-leader"
        COMPLETED_FILE="/var/www/localhost/htdocs/openemr/sites/docker-completed"
        if [ -f "$$COMPLETED_FILE" ]; then
          log "Setup completed successfully (docker-completed file exists), proceeding normally"
        elif [ -f "$$LEADER_FILE" ]; then
          log "docker-leader file exists but docker-completed does not, checking if leader is stale..."
          LEADER_MTIME=$$(stat -c %Y "$$LEADER_FILE" 2>/dev/null || stat -f %m "$$LEADER_FILE" 2>/dev/null || echo "")
          if [ -n "$$LEADER_MTIME" ] && [ "$$LEADER_MTIME" != "0" ]; then
            CURRENT_TIME=$$(date +%s)
            AGE_SECONDS=$$((CURRENT_TIME - LEADER_MTIME))
            if [ "$$AGE_SECONDS" -gt 1200 ]; then
              log "WARNING: Stale docker-leader file detected ($${AGE_SECONDS}s old, >20min). Leader likely failed mid-setup."
              log "This can cause 'Table already exists' errors. Cleaning up stale leader file..."
              rm -f "$$LEADER_FILE" || log "WARNING: Failed to remove stale leader file, continuing anyway"
              log "Stale leader file cleaned up. Another container can now become leader and handle partial database state."
            else
              log "docker-leader file is recent ($${AGE_SECONDS}s old), waiting for leader to complete setup..."
            fi
          else
            # If we can't determine file age (unlikely on Alpine), log but don't remove.
            # The openemr.sh script will handle waiting for completion.
            log "Could not determine age of docker-leader file. Will rely on openemr.sh timeout handling."
          fi
        else
          log "No docker-leader file found, this container may become the leader"
        fi
        log "Handing over to openemr.sh..."
        exec ./openemr.sh
    environment:
      # Mock database connection (use a local MySQL container or external)
      MYSQL_HOST: ${MYSQL_HOST:-mysql-test}
      MYSQL_ROOT_USER: ${MYSQL_ROOT_USER:-root}
      MYSQL_ROOT_PASS: ${MYSQL_ROOT_PASS:-testpass}
      MYSQL_USER: ${MYSQL_USER:-openemr}
      MYSQL_PASS: ${MYSQL_PASS:-openemr}
      MYSQL_DATABASE: ${MYSQL_DATABASE:-openemr}
      MYSQL_PORT: ${MYSQL_PORT:-3306}
      # For local testing, disable SSL since local MySQL doesn't have SSL configured.
      # In production (ECS), this will be ON to match RDS require_secure_transport=ON.
      MYSQL_SSL: ${MYSQL_SSL:-OFF}
      # OpenEMR admin credentials
      OE_USER: ${OE_USER:-admin}
      OE_PASS: ${OE_PASS:-pass}
      # Redis/Valkey configuration
      REDIS_SERVER: ${REDIS_SERVER:-redis-test}
      REDIS_TLS: ${REDIS_TLS:-OFF}
      # Swarm mode (set to yes to enable auto-setup)
      SWARM_MODE: ${SWARM_MODE:-yes}
      # Authority (set to yes for leader node)
      AUTHORITY: ${AUTHORITY:-yes}
    working_dir: /var/www/localhost/htdocs/openemr
    # volumes:
    #   # Mount the openemr.sh script if you want to test modifications
    #   # Note: Don't mount as read-only since chmod needs to work
    #   # You can find openemr-devops at: https://github.com/openemr/openemr-devops
    #   - ./openemr-devops/docker/openemr/7.0.4/openemr.sh:/var/www/localhost/htdocs/openemr/openemr.sh
    networks:
      - openemr-test-network
    depends_on:
      - mysql-test
      - redis-test
    # Keep container running to inspect logs
    stdin_open: true
    tty: true

  # Optional: Local MySQL for testing (if you don't have external DB)
  mysql-test:
    image: mariadb:11.8
    container_name: mysql-test
    environment:
      MYSQL_ROOT_PASSWORD: ${MYSQL_ROOT_PASS:-testpass}
      MYSQL_DATABASE: ${MYSQL_DATABASE:-openemr}
      MYSQL_USER: ${MYSQL_USER:-openemr}
      MYSQL_PASSWORD: ${MYSQL_PASS:-openemr}
    volumes:
      - mysql-test-data:/var/lib/mysql
    networks:
      - openemr-test-network
    # Note: For local testing, SSL is optional
    # Uncomment below to simulate RDS require_secure_transport=ON
    # command: --require-secure-transport=ON

  # Redis for caching and session management
  redis-test:
    image: redis:7-alpine
    container_name: redis-test
    command: redis-server --appendonly yes
    volumes:
      - redis-test-data:/data
    networks:
      - openemr-test-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 5

networks:
  openemr-test-network:
    driver: bridge

volumes:
  mysql-test-data:
  redis-test-data:

